// Copyright 2021 Tencent Inc. All rights reserved.
//
// 위챗페이 전자상거래 플랫폼 분할 API
//
// 위챗페이 전자상거래 플랫폼 분할 API
//
// API version: 1.0.21

// Code generated by WechatPay APIv3 Generator based on [OpenAPI
// Generator](https://openapi-generator.tech); DO NOT EDIT.

package com.wechat.pay.java.service.ecommerceprofitsharing.model;

import static com.wechat.pay.java.core.util.StringUtil.toIndentedString;

import com.google.gson.annotations.SerializedName;
import com.wechat.pay.java.core.cipher.Encryption;
import java.util.ArrayList;
import java.util.List;
import java.util.function.UnaryOperator;

/** CreateOrderRequest */
public class CreateOrderRequest {
  /** 위챗이 할당한 공개 계정 ID 설명: 위챗이 할당한 공개 계정 ID */
  @SerializedName("appid")
  private String appid;

  /** 전자상거래 플랫폼 하위 가맹점 번호 설명: 분할 출자 전자상거래 플랫폼 하위 가맹점, 위챗페이가 할당한 가맹점 번호를 기입 */
  @SerializedName("sub_mchid")
  private String subMchid;

  /** 위챗 주문 번호 설명: 위챗페이 주문 번호 */
  @SerializedName("transaction_id")
  private String transactionId;

  /** 가맹점 분할 내역 번호 설명: 가맹점 시스템 내부의 분할 내역 번호, 가맹점 시스템 내부에서 고유함(단일 분할, 다중 분할, 완료 분할은 서로 다른 가맹점 분할 내역 번호를 사용해야 함), 동일 분할 내역 번호로 여러 번 요청하면 한 번과 동일함. 숫자, 대소문자 영문, _, -, |, *, @만 가능 */
  @SerializedName("out_order_no")
  private String outOrderNo;

  /** 분할 수신자 목록 설명: 분할 수신자 목록, 출자 가맹점을 분할 수신자로 설정 가능 */
  @Encryption
  @SerializedName("receivers")
  private List<CreateOrderReceiver> receivers = new ArrayList<CreateOrderReceiver>();

  /**
   * 분할 완료 여부 설명: true인 경우, 분할 수신 가맹점은 전자상거래 플랫폼 가맹점만 지원하며, 해당 주문의 잔여 미분할 금액은 전자상거래 플랫폼 하위 가맹점으로 해동됨;
   * false인 경우, 분할 수신 가맹점은 전자상거래 플랫폼 가맹점 또는 전자상거래 플랫폼 하위 가맹점이 가능하며, 해당 주문의 잔여 미분할 금액은 전자상거래 플랫폼 하위 가맹점으로 해동되지 않으며, 해당 주문에 대해 다시 분할 가능;
   */
  @SerializedName("finish")
  private Boolean finish;

  /** 분할 결과 콜백 url 설명: 비동기로 위챗페이 분할 결과 알림을 수신하는 콜백 주소, 알림 url은 외부 네트워크에서 접근 가능한 url이어야 하며, 매개변수를 포함할 수 없음 */
  @SerializedName("notify_url")
  private String notifyUrl;

  public String getAppid() {
    return appid;
  }

  public void setAppid(String appid) {
    this.appid = appid;
  }

  public String getSubMchid() {
    return subMchid;
  }

  public void setSubMchid(String subMchid) {
    this.subMchid = subMchid;
  }

  public String getTransactionId() {
    return transactionId;
  }

  public void setTransactionId(String transactionId) {
    this.transactionId = transactionId;
  }

  public String getOutOrderNo() {
    return outOrderNo;
  }

  public void setOutOrderNo(String outOrderNo) {
    this.outOrderNo = outOrderNo;
  }

  public List<CreateOrderReceiver> getReceivers() {
    return receivers;
  }

  public void setReceivers(List<CreateOrderReceiver> receivers) {
    this.receivers = receivers;
  }

  public Boolean getFinish() {
    return finish;
  }

  public void setFinish(Boolean finish) {
    this.finish = finish;
  }

  public String getNotifyUrl() {
    return notifyUrl;
  }

  public void setNotifyUrl(String notifyUrl) {
    this.notifyUrl = notifyUrl;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateOrderRequest {\n");
    sb.append("    appid: ").append(toIndentedString(appid)).append("\n");
    sb.append("    subMchid: ").append(toIndentedString(subMchid)).append("\n");
    sb.append("    transactionId: ").append(toIndentedString(transactionId)).append("\n");
    sb.append("    outOrderNo: ").append(toIndentedString(outOrderNo)).append("\n");
    sb.append("    receivers: ").append(toIndentedString(receivers)).append("\n");
    sb.append("    finish: ").append(toIndentedString(finish)).append("\n");
    sb.append("    notifyUrl: ").append(toIndentedString(notifyUrl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  public CreateOrderRequest cloneWithCipher(UnaryOperator<String> s) {
    CreateOrderRequest copy = new CreateOrderRequest();
    copy.appid = appid;
    copy.subMchid = subMchid;
    copy.transactionId = transactionId;
    copy.outOrderNo = outOrderNo;
    if (receivers != null && receivers.size() != 0) {
      // arr
      copy.receivers = new ArrayList<>();
      for (CreateOrderReceiver val : receivers) {
        if (val != null) {
          copy.receivers.add(val.cloneWithCipher(s));
        }
      }
    }
    copy.finish = finish;
    copy.notifyUrl = notifyUrl;
    return copy;
  }
}
