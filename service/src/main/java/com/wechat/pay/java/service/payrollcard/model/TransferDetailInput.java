// Copyright 2021 Tencent Inc. All rights reserved.
//
// 급여 카드 인터페이스 문서
//
// 서비스 제공업체는 본 API 문서에서 제공하는 인터페이스를 통해 가맹점과 급여 카드의 인증 관계 조회, 사전 인증 token 비밀번호 생성, 신원 확인 사전 주문, 신원 확인 결과 조회 등을 수행합니다。
//
// API version: 1.5.2

// Code generated by WechatPay APIv3 Generator based on [OpenAPI
// Generator](https://openapi-generator.tech); DO NOT EDIT.

package com.wechat.pay.java.service.payrollcard.model;

import static com.wechat.pay.java.core.util.StringUtil.toIndentedString;

import com.google.gson.annotations.SerializedName;
import com.wechat.pay.java.core.cipher.Encryption;
import java.util.function.UnaryOperator;

/** TransferDetailInput */
public class TransferDetailInput {
  /** 가맹점 명세서 번호 설명: 가맹점 시스템 내부에서 이체 배치서 하의 서로 다른 이체 명세서를 구분하는 고유 식별자 */
  @SerializedName("out_detail_no")
  private String outDetailNo;

  /** 이체 금액 설명: 이체 금액 단위는 "분"입니다 */
  @SerializedName("transfer_amount")
  private Long transferAmount;

  /** 이체 비고 설명: 단일 이체 비고 (위챗 사용자가 이 비고를 받습니다), UTF8 인코딩, 최대 32자 허용 */
  @SerializedName("transfer_remark")
  private String transferRemark;

  /** 수취인 사용자 OpenID 설명: 수취인 사용자 OpenID. 이체 특약 가맹점 인증 유형이 INFORMATION_AUTHORIZATION_TYPE인 경우, 특약 가맹점 공개 계정 하의 OpenID에 해당합니다. */
  @SerializedName("openid")
  private String openid;

  /**
   * 수취인 사용자 이름 설명: 수취인 사용자 이름. 표준 RSA 알고리즘을 사용하며, 공개 키는 위챗 측에서 제공합니다. 명세서 이체 금액 >= 2,000일 때, 해당 명세서는 반드시 수취인 사용자 이름을 입력해야 합니다.
   * 동일 배치 이체 명세서의 이름 필드 전달 규칙은 일관성을 유지해야 하며, 즉 모두 입력하거나 모두 입력하지 않아야 합니다. 가맹점이 수취인 사용자 이름을 전달하면, 위챗페이는 사용자 OpenID와 이름이 일치하는지 검증하고 전자 영수증을 제공합니다.
   */
  @Encryption
  @SerializedName("user_name")
  private String userName;

  public String getOutDetailNo() {
    return outDetailNo;
  }

  public void setOutDetailNo(String outDetailNo) {
    this.outDetailNo = outDetailNo;
  }

  public Long getTransferAmount() {
    return transferAmount;
  }

  public void setTransferAmount(Long transferAmount) {
    this.transferAmount = transferAmount;
  }

  public String getTransferRemark() {
    return transferRemark;
  }

  public void setTransferRemark(String transferRemark) {
    this.transferRemark = transferRemark;
  }

  public String getOpenid() {
    return openid;
  }

  public void setOpenid(String openid) {
    this.openid = openid;
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TransferDetailInput {\n");
    sb.append("    outDetailNo: ").append(toIndentedString(outDetailNo)).append("\n");
    sb.append("    transferAmount: ").append(toIndentedString(transferAmount)).append("\n");
    sb.append("    transferRemark: ").append(toIndentedString(transferRemark)).append("\n");
    sb.append("    openid: ").append(toIndentedString(openid)).append("\n");
    sb.append("    userName: ").append(toIndentedString(userName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  public TransferDetailInput cloneWithCipher(UnaryOperator<String> s) {
    TransferDetailInput copy = new TransferDetailInput();
    copy.outDetailNo = outDetailNo;
    copy.transferAmount = transferAmount;
    copy.transferRemark = transferRemark;
    copy.openid = openid;
    if (userName != null && !userName.isEmpty()) {
      copy.userName = s.apply(userName);
    }
    return copy;
  }
}
